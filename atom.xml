<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>陈寄文的技术博客</title>
  <subtitle>一个码农的心得体会--人世沧桑，心已经疲倦</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://bazhuang.github.io/"/>
  <updated>2017-04-18T10:37:30.000Z</updated>
  <id>http://bazhuang.github.io/</id>
  
  <author>
    <name>chenjw</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title></title>
    <link href="http://bazhuang.github.io/2017/04/18/atom_install_package/"/>
    <id>http://bazhuang.github.io/2017/04/18/atom_install_package/</id>
    <published>2017-04-18T10:37:30.000Z</published>
    <updated>2017-04-18T10:37:30.000Z</updated>
    
    <content type="html">&lt;h1 id=&quot;atom中如何安装插件&quot;&gt;&lt;a href=&quot;#atom中如何安装插件&quot; class=&quot;headerlink&quot; title=&quot;atom中如何安装插件&quot;&gt;&lt;/a&gt;atom中如何安装插件&lt;/h1&gt;&lt;h2 id=&quot;困难&quot;&gt;&lt;a href=&quot;#困难&quot; class=&quot;headerlink&quot; title=&quot;困难&quot;&gt;&lt;/a&gt;困难&lt;/h2&gt;&lt;p&gt;通过直接方式安装插件，很难安装成功，总是会出现错误。错误的内容大体如下：&lt;br&gt;&lt;img src=&quot;https://cloud.githubusercontent.com/assets/606885/8377638/25167af2-1c13-11e5-9d49-e307f88ffba7.png&quot; alt=&quot;错误提示&quot;&gt;&lt;/p&gt;
&lt;p&gt;归根结底都是由于连接不上atom.io服务器造成的。&lt;/p&gt;
&lt;h2 id=&quot;解决办法&quot;&gt;&lt;a href=&quot;#解决办法&quot; class=&quot;headerlink&quot; title=&quot;解决办法&quot;&gt;&lt;/a&gt;解决办法&lt;/h2&gt;&lt;p&gt;解决办法可以有2个：&lt;/p&gt;
&lt;h3 id=&quot;（1）-配置apm镜像&quot;&gt;&lt;a href=&quot;#（1）-配置apm镜像&quot; class=&quot;headerlink&quot; title=&quot;（1） 配置apm镜像&quot;&gt;&lt;/a&gt;（1） 配置apm镜像&lt;/h3&gt;&lt;p&gt;在我们的当前用户目录下找到.atom目录，找到里面的.apmrc文件，如果没有的话就新建一个。&lt;/p&gt;
&lt;p&gt;里面的内容填上&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;registry = https://registry.npm.taobao.org&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;使用淘宝提供的npm镜像地址，然后通过命令apm install &lt;em&gt;*&lt;/em&gt; 安装插件。或者在atom里面安装也可以。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;assets/markdown-img-paste-20170418175646333.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;（2）配置代理&quot;&gt;&lt;a href=&quot;#（2）配置代理&quot; class=&quot;headerlink&quot; title=&quot;（2）配置代理&quot;&gt;&lt;/a&gt;（2）配置代理&lt;/h3&gt;&lt;p&gt;我这里使用的是shadowsocks，配置的话同样是~/.atom/.apmrc这个文件。里面配置的格式如下：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;http_proxy = socks5://127.0.0.1:1080&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;https_proxy = socks5://127.0.0.1:1080&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;具体是使用哪种代理方式就看大家选择的软件了。&lt;/p&gt;
&lt;p&gt;我自己这里使用的是第一种方式，方便快捷。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;atom中如何安装插件&quot;&gt;&lt;a href=&quot;#atom中如何安装插件&quot; class=&quot;headerlink&quot; title=&quot;atom中如何安装插件&quot;&gt;&lt;/a&gt;atom中如何安装插件&lt;/h1&gt;&lt;h2 id=&quot;困难&quot;&gt;&lt;a href=&quot;#困难&quot; class=&quot;head
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>ConcurrentHashMap在1.7和1.8下的不同实现</title>
    <link href="http://bazhuang.github.io/2017/03/21/ConcurrentHashMap-compare/"/>
    <id>http://bazhuang.github.io/2017/03/21/ConcurrentHashMap-compare/</id>
    <published>2017-03-21T14:11:06.000Z</published>
    <updated>2017-03-21T06:43:21.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;ConcurrentHashMap&quot;&gt;&lt;a href=&quot;#ConcurrentHashMap&quot; class=&quot;headerlink&quot; title=&quot;ConcurrentHashMap&quot;&gt;&lt;/a&gt;ConcurrentHashMap&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;转载自&lt;a href=&quot;http://www.jianshu.com/p/e694f1e868ec&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.jianshu.com/p/e694f1e868ec&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在多线程环境下，使用&lt;code&gt;HashMap&lt;/code&gt;进行&lt;code&gt;put&lt;/code&gt;操作时存在丢失数据的情况，为了避免这种bug的隐患，强烈建议使用&lt;code&gt;ConcurrentHashMap&lt;/code&gt;代替&lt;code&gt;HashMap&lt;/code&gt;，为了对&lt;code&gt;ConcurrentHashMap&lt;/code&gt;有更深入的了解，本文将对&lt;code&gt;ConcurrentHashMap&lt;/code&gt;1.7和1.8的不同实现进行分析。&lt;/p&gt;
&lt;h3 id=&quot;1-7-实现&quot;&gt;&lt;a href=&quot;#1-7-实现&quot; class=&quot;headerlink&quot; title=&quot;1.7 实现&quot;&gt;&lt;/a&gt;1.7 实现&lt;/h3&gt;&lt;h4 id=&quot;数据结构&quot;&gt;&lt;a href=&quot;#数据结构&quot; class=&quot;headerlink&quot; title=&quot;数据结构&quot;&gt;&lt;/a&gt;数据结构&lt;/h4&gt;&lt;p&gt;jdk1.7中采用&lt;code&gt;Segment&lt;/code&gt; + &lt;code&gt;HashEntry&lt;/code&gt;的方式进行实现，结构如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/2184951-af57d9d50ae9f547.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;http://upload-images.jianshu.io/upload_images/2184951-af57d9d50ae9f547.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ConcurrentHashMap&lt;/code&gt;初始化时，计算出&lt;code&gt;Segment&lt;/code&gt;数组的大小&lt;code&gt;ssize&lt;/code&gt;和每个&lt;code&gt;Segment&lt;/code&gt;中&lt;code&gt;HashEntry&lt;/code&gt;数组的大小&lt;code&gt;cap&lt;/code&gt;，并初始化&lt;code&gt;Segment&lt;/code&gt;数组的第一个元素；其中&lt;code&gt;ssize&lt;/code&gt;大小为2的幂次方，默认为16，&lt;code&gt;cap&lt;/code&gt;大小也是2的幂次方，最小值为2，最终结果根据根据初始化容量&lt;code&gt;initialCapacity&lt;/code&gt;进行计算，计算过程如下&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (c * ssize &amp;amp;lt; initialCapacity)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ++c;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; cap = MIN_SEGMENT_TABLE_CAPACITY;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; (cap &amp;amp;lt; c)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    cap &amp;amp;lt;&amp;amp;lt;= &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;其中&lt;code&gt;Segment&lt;/code&gt;在实现上继承了&lt;code&gt;ReentrantLock&lt;/code&gt;，这样就自带了锁的功能。&lt;/p&gt;&lt;br&gt;&lt;h4&gt;put实现&lt;/h4&gt;&lt;br&gt;&lt;p&gt;当执行&lt;code&gt;put&lt;/code&gt;方法插入数据时，根据key的hash值，在&lt;code&gt;Segment&lt;/code&gt;数组中找到相应的位置，如果相应位置的&lt;code&gt;Segment&lt;/code&gt;还未初始化，则通过CAS进行赋值，接着执行&lt;code&gt;Segment&lt;/code&gt;对象的&lt;code&gt;put&lt;/code&gt;方法通过加锁机制插入数据，实现如下：&lt;/p&gt;&lt;br&gt;&lt;p&gt;场景：线程A和线程B同时执行相同&lt;code&gt;Segment&lt;/code&gt;对象的&lt;code&gt;put&lt;/code&gt;方法&lt;/p&gt;&lt;br&gt;&lt;p&gt;1、线程A执行&lt;code&gt;tryLock()&lt;/code&gt;方法成功获取锁，则把&lt;code&gt;HashEntry&lt;/code&gt;对象插入到相应的位置；&lt;br&gt;2、线程B获取锁失败，则执行&lt;code&gt;scanAndLockForPut()&lt;/code&gt;方法，在&lt;code&gt;scanAndLockForPut&lt;/code&gt;方法中，会通过重复执行&lt;code&gt;tryLock()&lt;/code&gt;方法尝试获取锁，在多处理器环境下，重复次数为64，单处理器重复次数为1，当执行&lt;code&gt;tryLock()&lt;/code&gt;方法的次数超过上限时，则执行&lt;code&gt;lock()&lt;/code&gt;方法挂起线程B；&lt;br&gt;3、当线程A执行完插入操作时，会通过&lt;code&gt;unlock()&lt;/code&gt;方法释放锁，接着唤醒线程B继续执行；&lt;/p&gt;&lt;br&gt;&lt;h4&gt;size实现&lt;/h4&gt;&lt;br&gt;&lt;p&gt;因为&lt;code&gt;ConcurrentHashMap&lt;/code&gt;是可以并发插入数据的，所以在准确计算元素时存在一定的难度，一般的思路是统计每个&lt;code&gt;Segment&lt;/code&gt;对象中的元素个数，然后进行累加，但是这种方式计算出来的结果并不一样的准确的，因为在计算后面几个&lt;code&gt;Segment&lt;/code&gt;的元素个数时，已经计算过的&lt;code&gt;Segment&lt;/code&gt;同时可能有数据的插入或则删除，在1.7的实现中，采用了如下方式：&lt;/p&gt;&lt;br&gt;&lt;pre&gt;&lt;code&gt;try {&lt;br&gt;    for (;;) {&lt;br&gt;        if (retries++ == RETRIES_BEFORE_LOCK) {&lt;br&gt;            for (int j = 0; j &amp;lt; segments.length; ++j)&lt;br&gt;                ensureSegment(j).lock(); // force creation&lt;br&gt;        }&lt;br&gt;        sum = 0L;&lt;br&gt;        size = 0;&lt;br&gt;        overflow = false;&lt;br&gt;        for (int j = 0; j &amp;lt; segments.length; ++j) {&lt;br&gt;            Segment&amp;lt;K,V&amp;gt; seg = segmentAt(segments, j);&lt;br&gt;            if (seg != null) {&lt;br&gt;                sum += seg.modCount;&lt;br&gt;                int c = seg.count;&lt;br&gt;                if (c &amp;lt; 0 || (size += c) &amp;lt; 0)&lt;br&gt;                    overflow = true;&lt;br&gt;            }&lt;br&gt;        }&lt;br&gt;        if (sum == last)&lt;br&gt;            break;&lt;br&gt;        last = sum;&lt;br&gt;    }&lt;br&gt;} finally {&lt;br&gt;    if (retries &amp;gt; RETRIES_BEFORE_LOCK) {&lt;br&gt;        for (int j = 0; j &amp;lt; segments.length; ++j)&lt;br&gt;            segmentAt(segments, j).unlock();&lt;br&gt;    }&lt;br&gt;}&lt;/code&gt;&lt;/pre&gt;&lt;br&gt;&lt;p&gt;先采用不加锁的方式，连续计算元素的个数，最多计算3次：&lt;br&gt;1、如果前后两次计算结果相同，则说明计算出来的元素个数是准确的；&lt;br&gt;2、如果前后两次计算结果都不同，则给每个&lt;code&gt;Segment&lt;/code&gt;进行加锁，再计算一次元素的个数；&lt;/p&gt;&lt;br&gt;&lt;h3&gt;1.8实现&lt;/h3&gt;&lt;br&gt;&lt;h4&gt;数据结构&lt;/h4&gt;&lt;br&gt;&lt;p&gt;1.8中放弃了&lt;code&gt;Segment&lt;/code&gt;臃肿的设计，取而代之的是采用&lt;code&gt;Node&lt;/code&gt; + &lt;code&gt;CAS&lt;/code&gt; + &lt;code&gt;Synchronized&lt;/code&gt;来保证并发安全进行实现，结构如下：&lt;/p&gt;&lt;br&gt;&lt;div class=&quot;image-package&quot;&gt;&lt;br&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/2184951-d9933a0302f72d47.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; data-original-src=&quot;http://upload-images.jianshu.io/upload_images/2184951-d9933a0302f72d47.png?imageMogr2/auto-orient/strip%7CimageView2/2&quot;&gt;&lt;br&gt;&lt;div class=&quot;image-caption&quot;&gt;&lt;/div&gt;&lt;br&gt;&lt;/div&gt;&lt;br&gt;&lt;p&gt;只有在执行第一次&lt;code&gt;put&lt;/code&gt;方法时才会调用&lt;code&gt;initTable()&lt;/code&gt;初始化&lt;code&gt;Node&lt;/code&gt;数组，实现如下：&lt;/p&gt;&lt;br&gt;&lt;pre&gt;&lt;code&gt;private final Node&amp;lt;K,V&amp;gt;[] initTable() {&lt;br&gt;    Node&amp;lt;K,V&amp;gt;[] tab; int sc;&lt;br&gt;    while ((tab = table) == null || tab.length == 0) {&lt;br&gt;        if ((sc = sizeCtl) &amp;lt; 0)&lt;br&gt;            Thread.yield(); // lost initialization race; just spin&lt;br&gt;        else if (U.compareAndSwapInt(this, SIZECTL, sc, -1)) {&lt;br&gt;            try {&lt;br&gt;                if ((tab = table) == null || tab.length == 0) {&lt;br&gt;                    int n = (sc &amp;gt; 0) ? sc : DEFAULT_CAPACITY;&lt;br&gt;                    @SuppressWarnings(“unchecked”)&lt;br&gt;                    Node&amp;lt;K,V&amp;gt;[] nt = (Node&amp;lt;K,V&amp;gt;[])new Node&amp;lt;?,?&amp;gt;[n];&lt;br&gt;                    table = tab = nt;&lt;br&gt;                    sc = n - (n &amp;gt;&amp;gt;&amp;gt; 2);&lt;br&gt;                }&lt;br&gt;            } finally {&lt;br&gt;                sizeCtl = sc;&lt;br&gt;            }&lt;br&gt;            break;&lt;br&gt;        }&lt;br&gt;    }&lt;br&gt;    return tab;&lt;br&gt;}&lt;/code&gt;&lt;/pre&gt;&lt;br&gt;&lt;h4&gt;put实现&lt;/h4&gt;&lt;br&gt;&lt;p&gt;当执行&lt;code&gt;put&lt;/code&gt;方法插入数据时，根据key的hash值，在&lt;code&gt;Node&lt;/code&gt;数组中找到相应的位置，实现如下：&lt;/p&gt;&lt;br&gt;&lt;p&gt;1、如果相应位置的&lt;code&gt;Node&lt;/code&gt;还未初始化，则通过CAS插入相应的数据；&lt;/p&gt;&lt;br&gt;&lt;pre&gt;&lt;code&gt;else if ((f = tabAt(tab, i = (n - 1) &amp;amp; hash)) == null) {&lt;br&gt;    if (casTabAt(tab, i, null, new Node&amp;lt;K,V&amp;gt;(hash, key, value, null)))&lt;br&gt;        break;                   // no lock when adding to empty bin&lt;br&gt;}&lt;/code&gt;&lt;/pre&gt;&lt;br&gt;&lt;p&gt;2、如果相应位置的&lt;code&gt;Node&lt;/code&gt;不为空，且当前该节点不处于移动状态，则对该节点加&lt;code&gt;synchronized&lt;/code&gt;锁，如果该节点的&lt;code&gt;hash&lt;/code&gt;不小于0，则遍历链表更新节点或插入新节点；&lt;/p&gt;&lt;br&gt;&lt;pre&gt;&lt;code&gt;if (fh &amp;gt;= 0) {&lt;br&gt;    binCount = 1;&lt;br&gt;    for (Node&amp;lt;K,V&amp;gt; e = f;; ++binCount) {&lt;br&gt;        K ek;&lt;br&gt;        if (e.hash == hash &amp;amp;&amp;amp;&lt;br&gt;            ((ek = e.key) == key ||&lt;br&gt;             (ek != null &amp;amp;&amp;amp; key.equals(ek)))) {&lt;br&gt;            oldVal = e.val;&lt;br&gt;            if (!onlyIfAbsent)&lt;br&gt;                e.val = value;&lt;br&gt;            break;&lt;br&gt;        }&lt;br&gt;        Node&amp;lt;K,V&amp;gt; pred = e;&lt;br&gt;        if ((e = e.next) == null) {&lt;br&gt;            pred.next = new Node&amp;lt;K,V&amp;gt;(hash, key, value, null);&lt;br&gt;            break;&lt;br&gt;        }&lt;br&gt;    }&lt;br&gt;}&lt;/code&gt;&lt;/pre&gt;&lt;br&gt;&lt;p&gt;3、如果该节点是&lt;code&gt;TreeBin&lt;/code&gt;类型的节点，说明是红黑树结构，则通过&lt;code&gt;putTreeVal&lt;/code&gt;方法往红黑树中插入节点；&lt;/p&gt;&lt;br&gt;&lt;pre&gt;&lt;code&gt;else if (f instanceof TreeBin) {&lt;br&gt;    Node&amp;lt;K,V&amp;gt; p;&lt;br&gt;    binCount = 2;&lt;br&gt;    if ((p = ((TreeBin&amp;lt;K,V&amp;gt;)f).putTreeVal(hash, key, value)) != null) {&lt;br&gt;        oldVal = p.val;&lt;br&gt;        if (!onlyIfAbsent)&lt;br&gt;            p.val = value;&lt;br&gt;    }&lt;br&gt;}&lt;/code&gt;&lt;/pre&gt;&lt;br&gt;&lt;p&gt;4、如果&lt;code&gt;binCount&lt;/code&gt;不为0，说明&lt;code&gt;put&lt;/code&gt;操作对数据产生了影响，如果当前链表的个数达到8个，则通过&lt;code&gt;treeifyBin&lt;/code&gt;方法转化为红黑树，如果&lt;code&gt;oldVal&lt;/code&gt;不为空，说明是一次更新操作，没有对元素个数产生影响，则直接返回旧值；&lt;/p&gt;&lt;br&gt;&lt;pre&gt;&lt;code&gt;if (binCount != 0) {&lt;br&gt;    if (binCount &amp;gt;= TREEIFY_THRESHOLD)&lt;br&gt;        treeifyBin(tab, i);&lt;br&gt;    if (oldVal != null)&lt;br&gt;        return oldVal;&lt;br&gt;    break;&lt;br&gt;}&lt;/code&gt;&lt;/pre&gt;&lt;br&gt;&lt;p&gt;5、如果插入的是一个新节点，则执行&lt;code&gt;addCount()&lt;/code&gt;方法尝试更新元素个数&lt;code&gt;baseCount&lt;/code&gt;；&lt;/p&gt;&lt;br&gt;&lt;h4&gt;size实现&lt;/h4&gt;&lt;br&gt;&lt;p&gt;1.8中使用一个&lt;code&gt;volatile&lt;/code&gt;类型的变量&lt;code&gt;baseCount&lt;/code&gt;记录元素的个数，当插入新数据或则删除数据时，会通过&lt;code&gt;addCount()&lt;/code&gt;方法更新&lt;code&gt;baseCount&lt;/code&gt;，实现如下：&lt;/p&gt;&lt;br&gt;&lt;pre&gt;&lt;code&gt;if ((as = counterCells) != null ||&lt;br&gt;    !U.compareAndSwapLong(this, BASECOUNT, b = baseCount, s = b + x)) {&lt;br&gt;    CounterCell a; long v; int m;&lt;br&gt;    boolean uncontended = true;&lt;br&gt;    if (as == null || (m = as.length - 1) &amp;lt; 0 ||&lt;br&gt;        (a = as[ThreadLocalRandom.getProbe() &amp;amp; m]) == null ||&lt;br&gt;        !(uncontended =&lt;br&gt;          U.compareAndSwapLong(a, CELLVALUE, v = a.value, v + x))) {&lt;br&gt;        fullAddCount(x, uncontended);&lt;br&gt;        return;&lt;br&gt;    }&lt;br&gt;    if (check &amp;lt;= 1)&lt;br&gt;        return;&lt;br&gt;    s = sumCount();&lt;br&gt;}&lt;/code&gt;&lt;/pre&gt;&lt;br&gt;&lt;p&gt;1、初始化时&lt;code&gt;counterCells&lt;/code&gt;为空，在并发量很高时，如果存在两个线程同时执行&lt;code&gt;CAS&lt;/code&gt;修改&lt;code&gt;baseCount&lt;/code&gt;值，则失败的线程会继续执行方法体中的逻辑，使用&lt;code&gt;CounterCell&lt;/code&gt;记录元素个数的变化；&lt;/p&gt;&lt;br&gt;&lt;p&gt;2、如果&lt;code&gt;CounterCell&lt;/code&gt;数组&lt;code&gt;counterCells&lt;/code&gt;为空，调用&lt;code&gt;fullAddCount()&lt;/code&gt;方法进行初始化，并插入对应的记录数，通过&lt;code&gt;CAS&lt;/code&gt;设置cellsBusy字段，只有设置成功的线程才能初始化&lt;code&gt;CounterCell&lt;/code&gt;数组，实现如下：&lt;/p&gt;&lt;br&gt;&lt;pre&gt;&lt;code&gt;else if (cellsBusy == 0 &amp;amp;&amp;amp; counterCells == as &amp;amp;&amp;amp;&lt;br&gt;         U.compareAndSwapInt(this, CELLSBUSY, 0, 1)) {&lt;br&gt;    boolean init = false;&lt;br&gt;    try {                           // Initialize table&lt;br&gt;        if (counterCells == as) {&lt;br&gt;            CounterCell[] rs = new CounterCell[2];&lt;br&gt;            rs[h &amp;amp; 1] = new CounterCell(x);&lt;br&gt;            counterCells = rs;&lt;br&gt;            init = true;&lt;br&gt;        }&lt;br&gt;    } finally {&lt;br&gt;        cellsBusy = 0;&lt;br&gt;    }&lt;br&gt;    if (init)&lt;br&gt;        break;&lt;br&gt;}&lt;/code&gt;&lt;/pre&gt;&lt;br&gt;&lt;p&gt;3、如果通过&lt;code&gt;CAS&lt;/code&gt;设置cellsBusy字段失败的话，则继续尝试通过&lt;code&gt;CAS&lt;/code&gt;修改&lt;code&gt;baseCount&lt;/code&gt;字段，如果修改&lt;code&gt;baseCount&lt;/code&gt;字段成功的话，就退出循环，否则继续循环插入&lt;code&gt;CounterCell&lt;/code&gt;对象；&lt;/p&gt;&lt;br&gt;&lt;pre&gt;&lt;code&gt;else if (U.compareAndSwapLong(this, BASECOUNT, v = baseCount, v + x))&lt;br&gt;    break;&lt;/code&gt;&lt;/pre&gt;&lt;br&gt;&lt;p&gt;所以在1.8中的&lt;code&gt;size&lt;/code&gt;实现比1.7简单多，因为元素个数保存&lt;code&gt;baseCount&lt;/code&gt;中，部分元素的变化个数保存在&lt;code&gt;CounterCell&lt;/code&gt;数组中，实现如下：&lt;/p&gt;&lt;br&gt;&lt;pre&gt;&lt;code&gt;public int size() {&lt;br&gt;    long n = sumCount();&lt;br&gt;    return ((n &amp;lt; 0L) ? 0 :&lt;br&gt;            (n &amp;gt; (long)Integer.MAX_VALUE) ? Integer.MAX_VALUE :&lt;br&gt;            (int)n);&lt;br&gt;}&lt;br&gt;&lt;br&gt;final long sumCount() {&lt;br&gt;    CounterCell[] as = counterCells; CounterCell a;&lt;br&gt;    long sum = baseCount;&lt;br&gt;    if (as != null) {&lt;br&gt;        for (int i = 0; i &amp;lt; as.length; ++i) {&lt;br&gt;            if ((a = as[i]) != null)&lt;br&gt;                sum += a.value;&lt;br&gt;        }&lt;br&gt;    }&lt;br&gt;    return sum;&lt;br&gt;}&lt;/code&gt;&lt;/pre&gt;&lt;br&gt;&lt;p&gt;通过累加&lt;code&gt;baseCount&lt;/code&gt;和&lt;code&gt;CounterCell&lt;/code&gt;数组中的数量，即可得到元素的总个数。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;ConcurrentHashMap&quot;&gt;&lt;a href=&quot;#ConcurrentHashMap&quot; class=&quot;headerlink&quot; title=&quot;ConcurrentHashMap&quot;&gt;&lt;/a&gt;ConcurrentHashMap&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;转载自&lt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>利用hexo搭建github个人博客</title>
    <link href="http://bazhuang.github.io/2016/05/05/hexo-build-github-blog/"/>
    <id>http://bazhuang.github.io/2016/05/05/hexo-build-github-blog/</id>
    <published>2016-05-05T15:24:31.000Z</published>
    <updated>2017-03-21T06:09:27.000Z</updated>
    
    <content type="html">&lt;p&gt;作为开发人员，一般都会有自己的github账号。本人技术水平一般，没有什么代码可以贡献，比较懒也没有参与哪些开源项目。感谢那些大牛，给大家贡献了那么多丰富的开源项目。&lt;/p&gt;
&lt;p&gt;github还提供了免费的个人博客，而且空间是免费不限大小的，实在是太开心了。WordPress要自己搭建还是有点复杂。&lt;/p&gt;
&lt;h3 id=&quot;1、站点初始化&quot;&gt;&lt;a href=&quot;#1、站点初始化&quot; class=&quot;headerlink&quot; title=&quot;1、站点初始化&quot;&gt;&lt;/a&gt;1、站点初始化&lt;/h3&gt;&lt;p&gt;下面就介绍一下如何方便快捷的搭建一个个人博客：&lt;/p&gt;
&lt;h4 id=&quot;（1）申请一个新的repository&quot;&gt;&lt;a href=&quot;#（1）申请一个新的repository&quot; class=&quot;headerlink&quot; title=&quot;（1）申请一个新的repository&quot;&gt;&lt;/a&gt;（1）申请一个新的repository&lt;/h4&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/new&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://github.com/new&lt;/a&gt;，通过这个地址创建一个带有github.io地址的仓库。我的账号是buzhuang，所以我创建的就是bazhuang.github.io，到时候访问的时候就是&lt;a href=&quot;http://bazhuang.github.io&quot;&gt;bazhuang.github.io&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;2-设置仓库&quot;&gt;&lt;a href=&quot;#2-设置仓库&quot; class=&quot;headerlink&quot; title=&quot;(2) 设置仓库&quot;&gt;&lt;/a&gt;(2) 设置仓库&lt;/h4&gt;&lt;p&gt;找到刚才的仓库，进入settings界面，找到下面的如下区块：&lt;br&gt;&lt;img src=&quot;http://img2.tbcdn.cn/L1/461/1/736bf2ebd82f7aa8ca79281cefdc803dec2aba56&quot; alt=&quot;http://img2.tbcdn.cn/L1/461/1/736bf2ebd82f7aa8ca79281cefdc803dec2aba56&quot;&gt;&lt;br&gt;点击下面的Launch automatic page generator，按照提示操作，最后成功后，就会在上面显示Your site这个信息条了。&lt;/p&gt;
&lt;h4 id=&quot;3-然后访问网站&quot;&gt;&lt;a href=&quot;#3-然后访问网站&quot; class=&quot;headerlink&quot; title=&quot;(3) 然后访问网站&quot;&gt;&lt;/a&gt;(3) 然后访问网站&lt;/h4&gt;&lt;p&gt;如上操作，我们就可以访问博客网站了。我这里就是访问&lt;a href=&quot;http://bazhuang.github.io&quot;&gt;bazhuang.github.io&lt;/a&gt;，内容显示出来了就ok了。&lt;/p&gt;
&lt;h3 id=&quot;2、hexo搭建网站&quot;&gt;&lt;a href=&quot;#2、hexo搭建网站&quot; class=&quot;headerlink&quot; title=&quot;2、hexo搭建网站&quot;&gt;&lt;/a&gt;2、hexo搭建网站&lt;/h3&gt;&lt;p&gt;通过上述的方法创建出来的网站，如果需要增加网页内容，通过人肉写html代码显得不够高效。&lt;/p&gt;
&lt;p&gt;这里就该hexo上场了，我们可以用它来进行创建新文章，通过markdown语法来写文章，然后hexo一键发布上线。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://vioren.space/archives/hexo/#more&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;使用GitHub和Hexo搭建免费静态Blog&lt;/a&gt;，这篇文章就是介绍了如何搭建，这里就不再重复了。文章里面没有说如何自动发布。&lt;/p&gt;
&lt;h4 id=&quot;（1）配置-config-yml&quot;&gt;&lt;a href=&quot;#（1）配置-config-yml&quot; class=&quot;headerlink&quot; title=&quot;（1）配置_config.yml&quot;&gt;&lt;/a&gt;（1）配置_config.yml&lt;/h4&gt;&lt;p&gt;为了方便发布到github上，我们需要做一些配置。&lt;/p&gt;
&lt;p&gt;下面就是一个配置demo&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;42&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;43&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;44&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;45&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;46&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;47&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;48&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;49&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;50&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;51&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;52&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;53&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;54&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;55&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;# Hexo Configuration&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;## Docs: https://hexo.io/docs/configuration.html&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;## Source: https://github.com/hexojs/hexo/&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# Site&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;title: title&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;subtitle: subtitle&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;description:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;author: test&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;language: Chinese&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;timezone: UTC&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;url: http://demo.github.io&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;root: /&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;permalink: :year/:month/:day/:title/&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;permalink_defaults:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;source_dir: source&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;public_dir: public&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;tag_dir: tags&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;archive_dir: archives&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;category_dir: categories&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;code_dir: downloads/code&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;i18n_dir: :lang&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;skip_render:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;new_post_name: :title.md # File name of new posts&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;default_layout: post&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;titlecase: false # Transform title into titlecase&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;external_link: true # Open external links in new tab&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;filename_case: 0&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;render_drafts: false&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;post_asset_folder: false&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;relative_link: false&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;future: true&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;highlight:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  enable: true&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  line_number: true&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  auto_detect: false&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  tab_replace:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;default_category: uncategorized&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;category_map:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;tag_map:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;date_format: YYYY-MM-DD&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;time_format: HH:mm:ss&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;per_page: 10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;pagination_dir: page&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;theme: landscape&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;deploy:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  type: git&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  repo: https://github.com/demo/demo.github.io.git&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;对自动发布最重要的就是最后2行的信息，type写成git。repo就是github的仓库地址。&lt;/p&gt;
&lt;h4 id=&quot;（2）自动发布上线&quot;&gt;&lt;a href=&quot;#（2）自动发布上线&quot; class=&quot;headerlink&quot; title=&quot;（2）自动发布上线&quot;&gt;&lt;/a&gt;（2）自动发布上线&lt;/h4&gt;&lt;p&gt;通过hexo g可以编译源文件，然后通过hexo deploy命令可以完成最终网页文件的上传。第一次会让输入github的账号和密码。&lt;br&gt;发布完成之后，我们就可以刷新网站看到最新的内容了。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;作为开发人员，一般都会有自己的github账号。本人技术水平一般，没有什么代码可以贡献，比较懒也没有参与哪些开源项目。感谢那些大牛，给大家贡献了那么多丰富的开源项目。&lt;/p&gt;
&lt;p&gt;github还提供了免费的个人博客，而且空间是免费不限大小的，实在是太开心了。WordPre
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>清除 chrome 的 HSTS 307 缓存</title>
    <link href="http://bazhuang.github.io/2016/05/05/clean_chrome_hsts_cache/"/>
    <id>http://bazhuang.github.io/2016/05/05/clean_chrome_hsts_cache/</id>
    <published>2016-05-05T07:19:11.000Z</published>
    <updated>2016-05-05T07:19:11.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;清除-chrome-的-HSTS-307-缓存&quot;&gt;&lt;a href=&quot;#清除-chrome-的-HSTS-307-缓存&quot; class=&quot;headerlink&quot; title=&quot;清除 chrome 的 HSTS 307 缓存&quot;&gt;&lt;/a&gt;清除 chrome 的 HSTS 307 缓存&lt;/h2&gt;&lt;p&gt;现代浏览器和网页服务器都开始支持 &lt;a href=&quot;https://zh.wikipedia.org/wiki/HTTP%E4%B8%A5%E6%A0%BC%E4%BC%A0%E8%BE%93%E5%AE%89%E5%85%A8&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;HSTS 功能&lt;/a&gt;，即自动将不安全的 HTTP 请求使用 307 Internal Redirect 跳转到 HTTPS 请求。&lt;/p&gt;
&lt;p&gt;但是，用户的第一次访问还是不安全的。简单的说，在发生 307 的时候，用户可能就已经将用户名和密码暴露了。因为此时还是 HTTP 请求。&lt;/p&gt;
&lt;p&gt;而且，这个第一次还可能是每次浏览器启动的时候，也就是说，可能每天都会发生，甚至多次。&lt;/p&gt;
&lt;p&gt;所以，chrome 会自动记住每个域的 HSTS 设置。使得 HSTS 只是理论上的第一次暴露，后来就不经网页服务器返回，浏览器查询本地数据，直接伪造 HSTS 307 跳转到安全的 HTTPS，避免敏感数据的暴露。&lt;/p&gt;
&lt;p&gt;很遗憾的说，这个很贴心的功能有时会造成麻烦。也就是说，一旦网页服务器设置了 HSTS，浏览器记住了。那么，将不会再访问该域的 HTTP 了。即使是网页服务器端已经修改了相关配置。原因当然是，这个记住是浏览器本地的。&lt;/p&gt;
&lt;p&gt;还好，chrome 有暴露一些内部信息。不然就只有彻底删除浏览器才能清除。。。&lt;/p&gt;
&lt;p&gt;在地址栏打开 chrome://net-internals/#hsts 下方的 Query domain 可以查询指定的域是否有 HSTS 记录，存在的话，在 Delete domain 删除即可。&lt;/p&gt;
&lt;p&gt;转载自&lt;a href=&quot;https://larryli.cn/2015/02/644866&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://larryli.cn/2015/02/644866&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;清除-chrome-的-HSTS-307-缓存&quot;&gt;&lt;a href=&quot;#清除-chrome-的-HSTS-307-缓存&quot; class=&quot;headerlink&quot; title=&quot;清除 chrome 的 HSTS 307 缓存&quot;&gt;&lt;/a&gt;清除 chrome 的 HSTS 
    
    </summary>
    
    
  </entry>
  
</feed>
